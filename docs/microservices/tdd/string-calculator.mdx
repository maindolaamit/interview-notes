---
title: "String Calculator - TDD Example"
description: "Learn TDD with a simple string calculator that adds numbers"
sidebar_position: 1
---

# String Calculator - TDD Example

This is our first TDD example - a simple string calculator that can add numbers from a string input. This example demonstrates the basic TDD cycle: Red → Green → Refactor.

## Requirements

Create a calculator that:
1. Takes a string of numbers separated by commas
2. Returns the sum of those numbers
3. Handles empty strings (returns 0)
4. Handles single numbers
5. Handles multiple numbers

## TDD Implementation

### Step 1: Write a Failing Test (Red)

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class StringCalculatorTest {
    
    @Test
    public void testEmptyStringReturnsZero() {
        StringCalculator calculator = new StringCalculator();
        assertEquals(0, calculator.add(""));
    }
}
```

**Run the test** - it fails because `StringCalculator` class doesn't exist yet.

### Step 2: Write Minimal Code to Pass (Green)

```java
public class StringCalculator {
    public int add(String numbers) {
        return 0;
    }
}
```

**Run the test** - it passes! ✅

### Step 3: Add More Tests and Implement

```java
@Test
public void testSingleNumberReturnsThatNumber() {
    StringCalculator calculator = new StringCalculator();
    assertEquals(1, calculator.add("1"));
}

@Test
public void testTwoNumbersReturnsSum() {
    StringCalculator calculator = new StringCalculator();
    assertEquals(3, calculator.add("1,2"));
}
```

**Run tests** - they fail. Now implement the logic:

```java
public class StringCalculator {
    public int add(String numbers) {
        if (numbers.isEmpty()) {
            return 0;
        }
        
        String[] numberStrings = numbers.split(",");
        int sum = 0;
        for (String numberString : numberStrings) {
            sum += Integer.parseInt(numberString.trim());
        }
        return sum;
    }
}
```

**Run tests** - they pass! ✅

### Step 4: Refactor and Add More Features

Let's add support for multiple numbers and refactor:

```java
@Test
public void testMultipleNumbersReturnsSum() {
    StringCalculator calculator = new StringCalculator();
    assertEquals(6, calculator.add("1,2,3"));
}

@Test
public void testNumbersWithSpaces() {
    StringCalculator calculator = new StringCalculator();
    assertEquals(3, calculator.add("1, 2"));
}
```

Refactored implementation:

```java
public class StringCalculator {
    public int add(String numbers) {
        if (numbers.isEmpty()) {
            return 0;
        }
        
        return Arrays.stream(numbers.split(","))
                .map(String::trim)
                .mapToInt(Integer::parseInt)
                .sum();
    }
}
```

## Key TDD Lessons

1. **Start Simple**: Begin with the simplest case (empty string)
2. **One Test at a Time**: Add one test, make it pass, then move to the next
3. **Red-Green-Refactor**: Always follow this cycle
4. **Refactor Safely**: With tests in place, you can refactor confidently
5. **Incremental Development**: Build complexity gradually

## Complete Test Suite

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.util.Arrays;

public class StringCalculatorTest {
    
    private StringCalculator calculator = new StringCalculator();
    
    @Test
    public void testEmptyStringReturnsZero() {
        assertEquals(0, calculator.add(""));
    }
    
    @Test
    public void testSingleNumberReturnsThatNumber() {
        assertEquals(1, calculator.add("1"));
    }
    
    @Test
    public void testTwoNumbersReturnsSum() {
        assertEquals(3, calculator.add("1,2"));
    }
    
    @Test
    public void testMultipleNumbersReturnsSum() {
        assertEquals(6, calculator.add("1,2,3"));
    }
    
    @Test
    public void testNumbersWithSpaces() {
        assertEquals(3, calculator.add("1, 2"));
    }
}
```

## Next Steps

This basic example demonstrates the TDD cycle. In the next example, we'll tackle more complex requirements like input validation and error handling.