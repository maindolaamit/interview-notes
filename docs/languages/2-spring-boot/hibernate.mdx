---
title: JPA
description: "JPA & Hibernate"
sidebar_position: 2
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

**Spring's Role in JDBC Performance Optimization**

Using various JDBC performance optimization techniques, Spring leverages and enhances these techniques,
particularly through its transaction management and integration with connection pooling libraries.

Refresh your Knowledge on [Persistence](@docs/languages/java/persistence)

<Tabs>
    <TabItem value="Connection Pooling" label="Connection Pooling">
        * Understand the importance of connection pooling for reducing the overhead associated with establishing and
        closing database connections.
        * connection pools act as bounded buffers, leveling traffic spikes and preventing the database from becoming
        overwhelmed.
        * Note the significance of configuring the appropriate pool size based on application-specific database access
        patterns and connection usage monitoring.
        * Spring facilitates the integration of connection pooling solutions like HikariCP by providing configuration
        mechanisms to easily manage pool properties.

        For instance, Spring Boot applications using HikariCP can configure connection pool parameters like
        `maximumPoolSize`, `minimumIdle`, and `connectionTimeout` directly in the `application.properties` file.

    </TabItem>
    <TabItem value="Transaction Management" label="Transaction Management">

        * Spring's declarative transaction management, using annotations like `@Transactional`, simplifies the handling
        of transactions and promotes better resource utilization.
        * The `@Transactional(readOnly=true)` annotation optimizes read-only transactions by signaling to the underlying
        JPA provider and JDBC connection to potentially apply database-specific read-only optimizations.
        * Spring offers control over transaction isolation levels through the `isolation` attribute of the
        `@Transactional` annotation, allowing developers to fine-tune the level of concurrency and data consistency for
        their transactions.
        * The sources explain that while Java EE doesn't inherently support declarative read-only transactions or
        isolation level configuration, Spring provides these features, extending the capabilities of standard Java EE
        transaction management.
    </TabItem>

    <TabItem value="Batch Updates" label="Batch Updates">

        * Understand the benefits of using JDBC batch updates to group multiple DML statements into a single database
        request, reducing the number of database roundtrips and improving transaction response time.
        * Spring, particularly through Hibernate, supports transparent statement batching.
        * This allows developers to enable batch updates without significant code changes, even after the data access
        logic is already implemented.
        * Configuration properties like `spring.jpa.properties.hibernate.jdbc.batch_size` in Spring Boot allow for
        customizing the batch size to optimize performance further.

    </TabItem>

    <TabItem value="Statement Caching" label="Statement Caching">
        * Using caching, both server-side and client-side, can significantly improve performance by reusing parsed and
        optimized SQL statements.
        * They note that prepared statements, due to their parameterized nature, are more suitable for statement
        caching.
        * Spring's reliance on prepared statements in data access operations, particularly through JPA and Hibernate,
        naturally promotes the utilization of statement caching mechanisms.
        * The sources also highlight the importance of carefully managing statement cache size and configuration to
        prevent issues like cache eviction of frequently used statements.

    </TabItem>

    <TabItem value="Monitoring and Logging" label="Monitoring and Logging">

        * Advocate for monitoring database connections and logging SQL statements and parameters to gain insights into
        the performance of the data access layer.
        * They discuss tools like FlexyPool for connection monitoring and libraries like datasource-proxy and P6Spy for
        statement logging.
        * Spring facilitates the integration of these monitoring and logging tools, providing the flexibility to
        incorporate them into applications to enhance performance analysis and debugging.

    </TabItem>

    <TabItem value="Delaying Connection Acquisition" label="Delaying Connection Acquisition">

        * Acquiring database connections prematurely can lead to performance penalties, especially when there are
        long-running tasks before the first SQL statement execution.
        * They suggest informing Hibernate to disable auto-commit and delay connection acquisition until necessary.
        * Spring supports this optimization by allowing developers to disable auto-commit in connection pool
        configurations and through the `spring.jpa.properties.hibernate.connection.provider_disables_autocommit`
        property.

        In essence, Spring acts as a framework that simplifies and enhances the use of various JDBC performance
        optimization techniques. It provides developers with the tools and configuration options to leverage these
        techniques effectively, resulting in improved performance and scalability for data-intensive applications.

    </TabItem>
</Tabs>

---

:::tip
The auto-sharding topology is similar to the Multi-Master replication architecture as it can increase
throughput by distributing incoming load to multiple machines. While in a Multi-Master replicated
environment every node stores the whole database, the auto-sharding cluster distributes data so
that each shard is only a subset of the whole database.
:::

---
:::note
`@Repository` is useful for translating the
unchecked sQl specific exception to spring exceptions. This way, we have to
handle only DataAccessException
:::

## Associations

### One-to-Many
So, as a rule of thumb, always cascade from parent-side to child-side.
Setting `orphanRemoval=true` will delete the child entity when it is removed from the parent entity.

:::note
It's important to note that using a unidirectional @OneToMany association is less efficient as it uses a junction
table to manage the association, deviating from the typical one-to-many relationship.

While `orphanRemoval` or `cascadeType.REMOVE` does its work to remove the child entities but they may produce
a lot of SQL statements. So, it is better to use bulk operations.
:::

`cascadeType.ALL` which will cascade all the operations like `PERSIST`, `MERGE`, `REMOVE`, `REFRESH`, `DETACH` to the child entities.

`@ManyToOne` is the inverse side of `@OneToMany` and `@OneToOne` is the inverse side of `@OneToOne`.

<details>
    <summary>Example Entity</summary>

    ```java
    @Entity
    public class Department {
@Id
@GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String name;
    @OneToMany(cascade=CascadeType.ALL, mappedBy="department", orphanRemoval=true)
    private List<Employee> employees;
    // standard getters and setters
}

    @Entity
    public class Employee {
@Id
@GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String name;
    @ManyToOne
    private Department department;
    // standard getters and setters
}


    @Service
    @AllArgsConstructor
    public class Service {
@Autowired
    private Repository repository;

    @Transactional
    public void removeEmployee(Employee employee) {
    employee.getDepartment().getEmployees().remove(employee);
}

    @Transactional
    public void addEmployee(Employee employee) {
    repository.save(employee);
}

    @Transactional(readOnly=true)
    public void getEmployeeByDepartment(Department department) {
    List<Employee> employees = repository.findByDepartment(department);
    // do something with employees
}
}
    ```
</details>

#### Pagination

```java
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    Page<Employee> findByDepartment(Department department, Pageable pageable);
}

@Service
@AllArgsConstructor
public class Service {
    @Autowired
    private EmployeeRepository repository;

    @Transactional(readOnly=true)
    public void getEmployeeByDepartment(Department department) {
        Page<Employee> employees = repository.findByDepartment(department, PageRequest.of(0, 10));
        // do something with employees
    }
}
```

### Many - to - Many
The bidirectional many - to - many association can be accessed from both sides, both can be parents.Using default `@ManyToMany` annotation will create a junction table to manage the association.It requires developer to choose the owner(mappedBy) of the association.

```java
@Entity
public class Employee {
    @Id
    @GeneratedValue(strategy=GenerationType.AUTO)
    private Long id;
    private String name;
    @ManyToMany
    private List<Project> projects;
    // standard getters and setters
}

@Entity
public class Project {
    @Id
    @GeneratedValue(strategy=GenerationType.AUTO)
    private Long id;
    private String name;
    @ManyToMany(mappedBy="projects", cascade={ CascadeType.PERSIST, CascadeType.MERGE })
    private Set<Employee> employees;
    // standard getters and setters
}
```

:::note
In most cases, cascading removals are bad ideas, for e.g.removing a project should not remove the employees.So avoid CascadeType.ALL, CascadeType.REMOVE and use CascadeType.PERSIST and CascadeType.MERGE.

**When using the `@ManyToMany` annotation, always use a`java.util.Set`.Do not use the`java.util.List`. * *
:::

:::tip
Using`@OrderBy` with HashSet will preserve the order of the loaded / fetched Set,
    but this is not consistent across the transient state.To get consistency across the transient state as well,
    consider explicitly using LinkedHashSet instead of HashSet.so, for full consistency, use:
```java
@ManyToMany(mappedBy = "books")
@OrderBy("name DESC")
private Set<Author> authors = new LinkedHashSet<>();
```
:::
---
### Hibernate
** JPA ** is only specification which clients can use to interact with the database.

Hibernate is one of the implementations of JPA.Hibernate is a high - performance Object / Relational persistence and query service.We can use various Hibernate - specific optimization techniques like identifier generators,
    effective entity fetching and state transitions, application - level transactions and entity caching.

JPQL(Java Persistence Querying Language) abstracts the common SQL syntax by subtracting
database specific querying features, so it lacks support for Window Functions, Common Table
Expressions, Derived tables or PIVOT.As opposed to JPA jOOQ(Java Object Oriented Query) embraces
database specific features and provide a type - safe query builder.

In application performane management the two most common metrics are:
    - * * Response Time ** : lower it is more responsive application is.
- * * Throughput ** : Defined as rate of completing incoming load or number of transactions executed
in a given time interval.


:::note
Asynchronous replication can provide better throughput, at the price of having to resolve update conflicts.The asynchronous Multi - Master replication
requires a conflict detection and an automatic conflict resolution algorithm.When a conflict is
detected, the automatic resolution tries to merge the two conflicting branches, and, in case it fails,
    manual intervention is required.
    :::



