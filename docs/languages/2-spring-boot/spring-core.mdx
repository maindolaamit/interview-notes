---
title: Core
description : "Spring core Interview Questions"
sidebar_position: 1
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Spring Core


`@SpringBootApplication` annotation marks the application class in as a configuration class.
It then begins auto-scanning all the classes on the Java classpath for other Spring beans.
```java

@SpringBootApplication
// @SpringBootApplication tells SpringBoot Framework it is Bootstrap class for the project
// it then begin auto-scanning all classes on the java path for other Spring beans
public class Example{
  public static void main(String... args){
    SpringApplication.run(Example.class, args);
    // The above run starts a spring container and returns a Spring Application context
  }
}
```

Unlike the traditional Spring `@Controller` annotation, `@RestController` doesn’t require you to return a ResponseBody
class from your method in the controller class.
This is all handled by the presence of the `@RestController` annotation, which includes the `@ResponseBody` annotation.

<details>
  <summary>Bean Factory</summary>

  `BeanFactory` is the central interface in Spring’s core container. It is responsible for managing the lifecycle of beans, instantiating and configuring them, wiring them together, and handling their dependencies.
  - **XmlBeanFactory:** Loads beans from an XML file.
  - **ClassPathXmlApplicationContext:** Loads beans from an XML file located in the classpath.
  - **FileSystemXmlApplicationContext:** Loads beans from an XML file in the filesystem.
  - **AnnotationConfigApplicationContext:** Loads beans from Java-based configuration classes.

  **BeanFactory Implementations**
</details>

<details>
  <summary>Application Context</summary>

  `ApplicationContext` is a sub-interface of BeanFactory. It is the central interface in Spring’s core container and is responsible for managing the lifecycle of beans, instantiating and configuring them, wiring them together, and handling their dependencies.
  **ApplicationContext Implementations**
  - **ClassPathXmlApplicationContext:** Loads beans from an XML file located in the classpath.
  - **FileSystemXmlApplicationContext:** Loads beans from an XML file in the filesystem.
  - **AnnotationConfigApplicationContext:** Loads beans from Java-based configuration classes.
</details>

<details>
  <summary>Spring IoC Container</summary>

  The Spring IoC container is responsible for managing the lifecycle of beans, instantiating and configuring them, wiring them together, and handling their dependencies.
</details>

You can use `@RequestMapping` at class or method level to define an HTTP Endpoint that service is going to expose.
When defined at class level, you are establishing the root of the Endpoint for all other endpoints in the controller.

:::tip
`@SpringBootApplication` annotation is used to mark the application class in Spring Boot. It is a convenience annotation that adds the following annotations:
- `@Configuration`: Indicates that the class is a configuration class.
- `@EnableAutoConfiguration`: Enables Spring Boot’s auto-configuration feature.
- `@ComponentScan`: Tells Spring to scan the current package and all sub-packages for components.
:::

### What is `Spring Bean`?
In Spring, a bean represents a managed object within your application. It can be any object you want to manage, like a service, a repository, a controller, or even a database connection. Spring handles the creation, configuration, and lifecycle of these beans, simplifying development and promoting best practices.

A Spring bean is an object that is instantiated, assembled, and managed by the Spring IoC container. It is the basic building block of a Spring application.

Bean creation and management are governed by the Spring Bean Life Cycle:

- Bean Instantiation: Spring creates an instance of the bean based on its configuration.
This can be done through various methods, like using a constructor, a static factory method, or even instantiating the class directly.
- Bean Properties: After creating the bean, Spring injects dependencies into its properties through Dependency Injection (DI).
This means it wires together the objects your bean needs to function, reducing tight coupling and making your code more modular and testable.
- Bean Initialization: You can define custom initialization logic for your beans using methods like init() or annotations like **@PostConstruct**.
This is where you can perform setup tasks like opening database connections or initializing internal state.
- Bean Usage: The bean is now ready to be used throughout your application.
You can access it from other beans or inject it into controllers, services, or any other component that needs it.
- Bean Destruction: When your application finishes or a bean is no longer needed, Spring performs bean destruction.
This might involve closing resources, ending background tasks, or performing any necessary cleanup. You can customize destruction logic using methods like **destroy()** or **@PreDestroy**.

:::tip
Below are the three methods we can use to invoke Bean Lifecycle.
- Using the Annotation @PostConstruct and @PreDestroy can define the bean lifecycle hooks.
- Configuring the method names in XML properties files, generally by giving the init and destroy methods. If you have so many beans then methods can be declared at the  config level rather than property level for every bean.
- Implementing the Interfaces InitializingBean and DisposableBean from org.springframework.beans.factory. This approach is not recommended but only for interview purposes.
:::


**`Bean Scopes`**: Spring provides different scopes for beans, this determines how many instances of your bean exist and how Spring manages their lifecycle.
Annotations: Spring uses annotations extensively to configure beans and their lifecycle stages. 
Learn about annotations like **@Component, @Autowired, @PostConstruct, and @PreDestroy** to effectively manage your beans.
<Tabs>
<TabItem value="Singelton">
- One instance per application.
- Default scope.
- Bean is cached in the Spring IoC container.
- All requests for the bean will return a shared instance, so it is not thread-safe.
</TabItem>
<TabItem value="Prototype">
- New instance every time.
- Bean is not cached in the Spring IoC container.
- All requests for the bean will return a new instance, so it is thread-safe.
</TabItem>
<TabItem value="Request">
- One instance per HTTP request.
- Bean is cached in the HTTP request scope.
- All requests for the bean will return a shared instance, so it is not thread-safe.
</TabItem>
</Tabs>

:::note
Spring also provides other scopes like session, application, and websocket. However, these are only available in a web-aware ApplicationContext.
**You can also define custom scopes by implementing the Scope interface.**
:::

<details>
    <summary>What is Bean Wiring?</summary>
    <div>
        **Bean wiring** is the process of connecting beans together to form an application. It is achieved by declaring dependencies between beans in the configuration metadata (XML, Java annotations, or Java code).

        The act of wiring beans together is called **Dependency Injection (DI)**, and it is one of the core principles of the Spring framework.
    </div>
</details>

:::note **Difference between a Spring Singleton and a Java Singleton?**
- A Spring Singleton is a bean that is instantiated once per application context. It is the default scope in Spring and is cached in the Spring IoC container.
- A Java Singleton is a design pattern that ensures a class has only one instance and provides a global point of access to it. It is implemented using static methods or static fields in the class.
:::

:::note **Difference between a Spring bean and a Java bean?**
- A Spring bean is an object that is instantiated, assembled, and managed by the Spring IoC container.
It is the basic building block of a Spring application.
- Spring bean is scoped to IoC, multiple IoC containers exist in an application.
- A Java bean is a reusable software component that conforms to certain design conventions, managed by class itself.
It is a Java class that should follow the JavaBeans naming conventions (e.g., getters/setters, Serializable interface, etc.).
- Java bean is scoped to JVM or classloader
:::

---

## Servlet Context

`ServletContext` is an interface that defines a set of methods that a servlet uses to communicate with its servlet container. It is an object that contains a servlet’s view of the web application within which the servlet is running.

### Web Service Deployment Architecture

When deploying a web service, it is hosted inside a **server** (e.g., JBoss, Tomcat).
The server contains a **Servlet Container**, which manages a **Servlet Context**.
The Servlet Context is used to configure one or more **Dispatcher Servlets**.

### Dispatcher Servlet:
- Acts as the front controller in the application.
- It is registered with the Servlet Container.
- Handles incoming web requests based on the URL mappings and descriptors defined in the `web.xml` file located in the `WEB-INF` folder.
- Routes requests to the appropriate controllers for processing.
Here’s a rephrased version of the given content for inclusion in a `README.md`:

The `Dispatcher Servlet` in a web application is responsible for processing incoming requests and generating the appropriate responses. It operates based on configurations defined in the `web.xml` file located in the `META-INF` folder. The servlet uses a `ViewResolver` to determine the correct view for rendering responses. Servers such as Tomcat automatically load this configuration and activate the Dispatcher Servlet.

---



### Servlet Context:
- An interface provided by the web server vendor (e.g., Tomcat is the default vendor for Spring Boot).
- The Servlet Container provides an implementation of `ServletContext` and creates one instance per web application.
- Shared across all servlets in the application, making it useful for sharing information (e.g., configuration or data) between servlets.


Here is a diagram illustrating the described architecture of deploying a web service in a server environment,
including the relationships between the **Server**, **Servlet Container**, **Servlet Context**, and **Dispatcher Servlet**:

```plaintext
+-------------------------+
|        Web Server       |
| (e.g., Tomcat, JBoss)   |
+-------------------------+
          |
          v
+-------------------------+
|    Servlet Container    | <--- Provides ServletContext object
+-------------------------+
          |
          v
+-------------------------+
|     Servlet Context     | <--- Shared across all Servlets
+-------------------------+
          |
          v
+-------------------------+                                        +-----------------------------------+
|   Dispatcher Servlet    | <--- Awaiting Incoming --------------> |  WebApplication Context           |
| (Front Controller)      |      HttpServlet requests              | + Controller                      |
|                         |      Handles HTTP requests             | + View Resolver, Local Resolver   |
+-------------------------+                                        +   and web related beans           |
          |                                                        +-----------------------------------+
          |
          v
+-------------------------+
| Appropriate Controller  | <--- Processes the request and sends a response
+-------------------------+
```

### Key Components:
1. **Web Server**: Hosts the application and provides the runtime environment for the servlet container (e.g., Tomcat, JBoss) [3][6].
2. **Servlet Container**: Manages servlets and provides an implementation of `ServletContext`, which is shared across servlets in the application [3][6].
3. **Servlet Context**: Allows sharing of information among servlets and is created once per web application by the container [3][5].
4. **Dispatcher Servlet**:
- Acts as the **Front Controller** in Spring MVC.
- Handles incoming HTTP requests based on URL mappings defined in `web.xml` or programmatically.
- Delegates requests to appropriate controllers for processing.

We can have one WebApplication context registered with a Dispatcher Servlet, it is a one-to-one mapping.
