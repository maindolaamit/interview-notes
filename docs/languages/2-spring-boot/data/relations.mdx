---
title: Relations
description: "One-to-Many and Many-to-Many Relationships in Hibernate"
sidebar_position: 2
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


:::tip
The auto-sharding topology is similar to the Multi-Master replication architecture as it can increase
throughput by distributing incoming load to multiple machines. While in a Multi-Master replicated
environment every node stores the whole database, the auto-sharding cluster distributes data so
that each shard is only a subset of the whole database.
:::

---

## Associations

### One-to-Many
So, as a rule of thumb, always cascade from parent-side to child-side.
Setting `orphanRemoval=true` will delete the child entity when it is removed from the parent entity.

:::note
It's important to note that using a unidirectional @OneToMany association is less efficient as it uses a junction
table to manage the association, deviating from the typical one-to-many relationship.

While `orphanRemoval` or `cascadeType.REMOVE` does its work to remove the child entities but they may produce
a lot of SQL statements. So, it is better to use bulk operations.
:::

`cascadeType.ALL` which will cascade all the operations like `PERSIST`, `MERGE`, `REMOVE`, `REFRESH`, `DETACH` to the child entities.

`@ManyToOne` is the inverse side of `@OneToMany` and `@OneToOne` is the inverse side of `@OneToOne`.

<details>
    <summary>Example Entity</summary>

    ```java
    @Entity
    public class Department {
@Id
@GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String name;
    @OneToMany(cascade=CascadeType.ALL, mappedBy="department", orphanRemoval=true)
    private List<Employee> employees;
    // standard getters and setters
}

    @Entity
    public class Employee {
@Id
@GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String name;
    @ManyToOne
    private Department department;
    // standard getters and setters
}


    @Service
    @AllArgsConstructor
    public class Service {
@Autowired
    private Repository repository;

    @Transactional
    public void removeEmployee(Employee employee) {
    employee.getDepartment().getEmployees().remove(employee);
}

    @Transactional
    public void addEmployee(Employee employee) {
    repository.save(employee);
}

    @Transactional(readOnly=true)
    public void getEmployeeByDepartment(Department department) {
    List<Employee> employees = repository.findByDepartment(department);
    // do something with employees
}
}
    ```
</details>

#### Pagination

```java
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    Page<Employee> findByDepartment(Department department, Pageable pageable);
}

@Service
@AllArgsConstructor
public class Service {
    @Autowired
    private EmployeeRepository repository;

    @Transactional(readOnly=true)
    public void getEmployeeByDepartment(Department department) {
        Page<Employee> employees = repository.findByDepartment(department, PageRequest.of(0, 10));
        // do something with employees
    }
}
```

### Many - to - Many
The bidirectional many - to - many association can be accessed from both sides, both can be parents.Using default `@ManyToMany` annotation will create a junction table to manage the association.It requires developer to choose the owner(mappedBy) of the association.

```java
@Entity
public class Employee {
    @Id
    @GeneratedValue(strategy=GenerationType.AUTO)
    private Long id;
    private String name;
    @ManyToMany
    private List<Project> projects;
    // standard getters and setters
}

@Entity
public class Project {
    @Id
    @GeneratedValue(strategy=GenerationType.AUTO)
    private Long id;
    private String name;
    @ManyToMany(mappedBy="projects", cascade={ CascadeType.PERSIST, CascadeType.MERGE })
    private Set<Employee> employees;
    // standard getters and setters
}
```

:::note
In most cases, cascading removals are bad ideas, for e.g.removing a project should not remove the employees.
So avoid CascadeType.ALL, CascadeType.REMOVE and use CascadeType.PERSIST and CascadeType.MERGE.

**When using the `@ManyToMany` annotation, always use a`java.util.Set`.Do not use the`java.util.List`.**
:::

:::tip
Using`@OrderBy` with HashSet will preserve the order of the loaded / fetched Set,
    but this is not consistent across the transient state.To get consistency across the transient state as well,
    consider explicitly using LinkedHashSet instead of HashSet.so, for full consistency, use:
```java
@ManyToMany(mappedBy = "books")
@OrderBy("name DESC")
private Set<Author> authors = new LinkedHashSet<>();
```
:::

---

### Hibernate
**JPA** is only specification which clients can use to interact with the database.

Hibernate is one of the implementations of JPA.Hibernate is a high - performance Object / Relational persistence and query service.We can use various Hibernate - specific optimization techniques like identifier generators,
    effective entity fetching and state transitions, application - level transactions and entity caching.

JPQL(Java Persistence Querying Language) abstracts the common SQL syntax by subtracting
database specific querying features, so it lacks support for Window Functions, Common Table
Expressions, Derived tables or PIVOT.As opposed to JPA jOOQ(Java Object Oriented Query) embraces
database specific features and provide a type - safe query builder.

In application performane management the two most common metrics are:
- **Response Time** : lower it is more responsive application is.
- **Throughput** : Defined as rate of completing incoming load or number of transactions executed
in a given time interval.


:::note
Asynchronous replication can provide better throughput, at the price of having to resolve update conflicts.
The asynchronous Multi - Master replication requires a conflict detection and an automatic conflict resolution algorithm.
When a conflict is detected, the automatic resolution tries to merge the two conflicting branches, and, in case it fails,
    manual intervention is required.
:::



