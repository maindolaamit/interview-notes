---
title: JavaScript
description : "JavaScript Interview Questions"
sidebar_position: 0
---


JavaScript is a high-level, interpreted programming language that conforms to the ECMAScript specification. JavaScript has curly-bracket syntax, dynamic typing, prototype-based object-orientation, and first-class functions.

### What is the difference between `null` and `undefined`?
`null` is an assigned value. It means nothing. `undefined` means a variable has been declared but has not yet been assigned a value.

### What is the difference between `==` and `===`?
`==` checks for equality only after doing necessary type conversions. `===` checks for equality without doing any type conversion.

### What is the difference between `let`, `var`, and `const`?

- `var` is function-scoped when declared inside a function.
- `let` is block-scoped.
- `const` is a constant value and cannot be reassigned.

### Describe how the this keyword works in different contexts (global, object methods, etc.).
`this` refers to the object it belongs to. It has different values depending on where it is used. 


### What is the difference between `function` and `arrow function`?
Arrow functions are always anonymous. Arrow functions do not have their own `this`. Arrow functions do not have arguments.


### What is the difference between `find` and `filter`?
`find` returns the first match. `filter` returns all matches.

### What is the difference between `map` and `forEach`?
`map` returns a new array with the results of calling a provided function on every element in the array.

### What is the difference between `slice` and `splice`?
`slice` does not modify the original array. `splice` modifies the original array.

### What is a closure?
In JavaScript, a closure is a fundamental concept that refers to the ability of a function to retain access to its 
lexical scope, even when the function is executed outside that scope.
This behavior allows functions to "remember" the environment in which they were created, enabling powerful programming patterns.
```javascript
function outerFunction() {
    let outerVariable = 'I am from outer scope!';

    function innerFunction() {
        console.log(outerVariable); // Accesses outerVariable
    }

    return innerFunction; // Returns the inner function
}

const closureFunction = outerFunction(); // Executes outerFunction
closureFunction(); // Outputs: I am from outer scope!
```

Use cases of closures include data privacy, currying, and partial application.
<details>
<summary>Data Privacy</summary>

They can create private variables that cannot be accessed from outside the function.
```javascript
function createCounter() {
    let count = 0; // Private variable
    return {
        increment: () => ++count,
        decrement: () => --count,
        getCount: () => count
    };
}

const counter = createCounter();
console.log(counter.getCount()); // Outputs: 0
counter.increment();
console.log(counter.getCount()); // Outputs: 1
```
</details>

<details>
<summary>Currying/Partial Application</summary>

They allow functions to be partially applied by retaining some arguments.
```javascript
function multiply(factor) {
    return function(x) {
        return x * factor;
    };
}

const double = multiply(2);
console.log(double(5)); // Outputs: 10
```
</details>

<details>
<summary>Event Handlers</summary>

Closures are often used in event handling to maintain state.
```javascript
function setupButton(buttonId) {
    let count = 0;
    document.getElementById(buttonId).addEventListener('click', function() {
        count++;
        console.log(`Button clicked ${count} times`);
    });
}

setupButton('myButton'); // Button clicks will increment count
```
</details>

### How can you optimize performance in a JavaScript application?
Optimizing performance in a JavaScript application is crucial for delivering a fast and responsive user experience.
Several strategies can be employed to enhance performance, such as:

- Minimizing DOM manipulation
- Reducing HTTP requests
- Implementing efficient algorithms
- Using event delegation
- Caching data
- Lazy loading resources
- Compressing files


### Explain `debouncing` and `throttling` in JavaScript with examples.
Debouncing and throttling are techniques used to limit the number of times a function is executed.
These methods are particularly useful when dealing with events that trigger multiple
times in a short period, such as scrolling, resizing, or typing.

<details>
<summary>Debouncing</summary>

Debouncing ensures that a function is only executed after a specified period of inactivity.
This technique is useful when you want to delay the execution of a function until the user stops performing an action.

```javascript
function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
            func.apply(this, args);
        }, delay);
    };
}

const debouncedFunction = debounce(() => {
    console.log('Function debounced');
}, 300);

window.addEventListener('scroll', debouncedFunction);
```
</details>

<details>

<summary>Throttling</summary>

Throttling limits the rate at which a function is executed. It ensures that the function is called at most once in a specified time interval.
This technique is useful when you want to control the frequency of function execution.

```javascript
function throttle(func, limit) {
    let inThrottle;
    return function(...args) {
        if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
        }
    };
}

const throttledFunction = throttle(() => {
    console.log('Function throttled');
}, 300);

window.addEventListener('scroll', throttledFunction);
```

</details>

### How do you handle asynchronous operations in JavaScript?
Handling asynchronous operations in JavaScript can be achieved through several methods,
primarily using `callbacks`, `promises`, and `async/await`.
Each approach has its own syntax and use cases, allowing developers to manage asynchronous code effectively.

<details>
<summary>Callbacks</summary>

Callbacks are functions passed as arguments to another function, which are then invoked when the operation completes.

```javascript
function fetchData(callback) {
    setTimeout(() => {
        const data = "Data fetched";
        callback(data);
    }, 2000);
}

fetchData((data) => {
    console.log(data); // Outputs: Data fetched
});
```
</details>

<details>
<summary>Promise</summary>

Promise is an object representing the eventual completion or failure of an asynchronous operation.
```javascript

const myPromise = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("Data fetched");
    }, 2000);
});

myPromise
    .then((data) => {
        console.log(data); // Outputs: Data fetched
    })
    .catch((error) => {
        console.error(error);
    });

```
</details>


### How does `promises` work in JavaScript?
Promises are objects representing the eventual completion or failure of an asynchronous operation.
A promise can be in one of three states: `pending`, `fulfilled`, or `rejected`.
When a promise is created, it is in the pending state. 
It can transition to the fulfilled state with a value or the rejected state with an error.

Promises are created using the `Promise` constructor, which takes an executor function as an argument.

```javascript

const myPromise = new Promise((resolve, reject) => {
    setTimeout(() => {
        const data = "Data fetched";
        resolve(data);
    }, 2000);
});

myPromise
    .then((data) => {
        console.log(data); // Outputs: Data fetched
    })
    .catch((error) => {
        console.error(error);
    });

```


### What is `async/await` in JavaScript?
`async/await` is a modern JavaScript feature that allows you to write asynchronous code in a synchronous manner.
It is built on top of promises and provides a more readable and structured way to handle asynchronous operations.

The `async` keyword is used to define an asynchronous function, which returns a promise.
The `await` keyword is used to pause the execution of an async function until a promise is settled.

```javascript
async function fetchData() {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    return data;
}

fetchData()
    .then((data) => {
        console.log(data);
    })
    .catch((error) => {
        console.error(error);
    });
```

### What is the event loop in JavaScript?
The event loop is a fundamental concept in JavaScript that allows the runtime environment to efficiently handle asynchronous operations.
It continuously checks the call stack for functions to execute and the callback queue for events to process.
The event loop follows a single-threaded, non-blocking model, ensuring that JavaScript remains responsive and performs efficiently.

The event loop consists of the following components:

- Call Stack: A data structure that records the functions to be executed.
- Web APIs: Browser-specific APIs that handle asynchronous operations.
- Callback Queue: A queue that stores events to be processed.
- Event Loop: A loop that continuously checks the call stack and callback queue.

The event loop operates as follows:

1. The call stack processes functions in a synchronous manner.
2. When an asynchronous operation is encountered, it is offloaded to the Web APIs.
3. Once the operation completes, the callback is added to the callback queue.
4. The event loop continuously checks the call stack and callback queue.
5. When the call stack is empty, the event loop moves the callback from the queue to the stack for execution.


### WHat is `Hoisting` in JavaScript?
Hoisting is a JavaScript mechanism where variables and function declarations are moved to the top of their containing scope during the compilation phase.
This behavior allows you to use variables and functions before they are declared in your code.

```javascript
console.log(myVariable); // Outputs: undefined
var myVariable = 'Hello, World!';

```

