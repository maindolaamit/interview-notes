---
title: JavaScript
description : "JavaScript Interview Questions"
sidebar_position: 0
---

## JavaScript Interview Questions

JavaScript is a high-level, interpreted programming language that conforms to the ECMAScript specification. JavaScript has curly-bracket syntax, dynamic typing, prototype-based object-orientation, and first-class functions.

### What is the difference between `null` and `undefined`?
`null` is an assigned value. It means nothing. `undefined` means a variable has been declared but has not yet been assigned a value.

### What is the difference between `==` and `===`?
`==` checks for equality only after doing necessary type conversions. `===` checks for equality without doing any type conversion.

### What is the difference between `let`, `var`, and `const`?

- `var` is function-scoped when declared inside a function.
- `let` is block-scoped.
- `const` is a constant value and cannot be reassigned.

### Describe how the this keyword works in different contexts (global, object methods, etc.).
`this` refers to the object it belongs to. It has different values depending on where it is used. 


### What is the difference between `function` and `arrow function`?
Arrow functions are always anonymous. Arrow functions do not have their own `this`. Arrow functions do not have arguments.


### What is the difference between `find` and `filter`?
`find` returns the first match. `filter` returns all matches.

### What is the difference between `slice` and `splice`?
`slice` does not modify the original array. `splice` modifies the original array.

### How do you handle asynchronous operations in JavaScript?
Handling asynchronous operations in JavaScript can be achieved through several methods,
primarily using `callbacks`, `promises`, and `async/await`.
Each approach has its own syntax and use cases, allowing developers to manage asynchronous code effectively.

<details>
<summary>Callbacks</summary>

Callbacks are functions passed as arguments to another function, which are then invoked when the operation completes.

```javascript
function fetchData(callback) {
    setTimeout(() => {
        const data = "Data fetched";
        callback(data);
    }, 2000);
}

fetchData((data) => {
    console.log(data); // Outputs: Data fetched
});
```
</details>

<details>
<summary>Promise</summary>

Promise is an object representing the eventual completion or failure of an asynchronous operation.
```javascript

const myPromise = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("Data fetched");
    }, 2000);
});

myPromise
    .then((data) => {
        console.log(data); // Outputs: Data fetched
    })
    .catch((error) => {
        console.error(error);
    });

```
</details>

### What is a closure?
In JavaScript, a closure is a fundamental concept that refers to the ability of a function to retain access to its 
lexical scope, even when the function is executed outside that scope.
This behavior allows functions to "remember" the environment in which they were created, enabling powerful programming patterns.
```javascript
function outerFunction() {
    let outerVariable = 'I am from outer scope!';

    function innerFunction() {
        console.log(outerVariable); // Accesses outerVariable
    }

    return innerFunction; // Returns the inner function
}

const closureFunction = outerFunction(); // Executes outerFunction
closureFunction(); // Outputs: I am from outer scope!
```

Use cases of closures include data privacy, currying, and partial application.
<details>
<summary>Data Privacy</summary>

They can create private variables that cannot be accessed from outside the function.
```javascript
function createCounter() {
    let count = 0; // Private variable
    return {
        increment: () => ++count,
        decrement: () => --count,
        getCount: () => count
    };
}

const counter = createCounter();
console.log(counter.getCount()); // Outputs: 0
counter.increment();
console.log(counter.getCount()); // Outputs: 1
```
</details>

<details>
<summary>Currying/Partial Application</summary>

They allow functions to be partially applied by retaining some arguments.
```javascript
function multiply(factor) {
    return function(x) {
        return x * factor;
    };
}

const double = multiply(2);
console.log(double(5)); // Outputs: 10
```
</details>

<details>
<summary>Event Handlers</summary>

Closures are often used in event handling to maintain state.
```javascript
function setupButton(buttonId) {
    let count = 0;
    document.getElementById(buttonId).addEventListener('click', function() {
        count++;
        console.log(`Button clicked ${count} times`);
    });
}

setupButton('myButton'); // Button clicks will increment count
```
</details>

### How can you optimize performance in a JavaScript application?
Optimizing performance in a JavaScript application is crucial for delivering a fast and responsive user experience.
Several strategies can be employed to enhance performance, such as:

- Minimizing DOM manipulation
- Reducing HTTP requests
- Implementing efficient algorithms
- Using event delegation
- Caching data
- Lazy loading resources
- Compressing files


